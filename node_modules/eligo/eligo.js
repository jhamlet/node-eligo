var utils = require('protean'),
    Jaunt = require('jaunt'),
    QueryEngine = require('eligo/query-engine'),
    Eligo;

Eligo = utils.classify({
    /**
     * @constructor
     * @param {Object} opts 
     *      @property {String} [opts.idKey] Object key to determine id attribute
     *      @property {String} [opts.typeKey] Object key to determine child nodes
     *      @property {Array|Object} [opts.childKeys] Child keys of nodes
     *      @property {Object} [opts.typeAliases] Mapping of alias to type
     *      @property {Boolean} [opts.esprima] Set to true to use standard esprima
     *          typeKey, childKeys and typeAliases
     * @param {Object} [obj] Optional object to query on
     */
    constructor: function Eligo (opts, obj) {
        this.options = opts || {};
        this.subject = obj;
    },
    /**
     * Return the first node that satisfies the query from obj
     * @param {Object} [obj] The object tree to query
     * @param {String|String[]} query The quer(y|ies) to run
     * @param {Boolean} [all=false] Get all nodes that match
     * @returns {Object|null}
     */
    select: function (obj, query, all) {
        var opts = this.options,
            results;
        
        if (typeof obj === 'string') {
            query = obj;
            obj = null;
        }
        
        this.reset();
        
        this.traverse(obj, query.toString(), !!all);
        
        results = this.results;
        
        return results.length ?
            all ? results : results[0] :
            null;
    },
    /**
     * Return all nodes that satisfy the query from obj
     * @param {Object} [obj] The object tree to query
     * @param {String|String[]} query The quer(y|ies) to run
     * @returns {Object[]|null}
     */
    selectAll: function (obj, query) {
        return this.select(obj, query, false);
    },
    /**
     * Traverse the supplied obj and test every node against the supplied
     * queries.  If the optional 'breakOnFirst' parameter is truthy, then
     * break when the first node matches any of the given queries.
     * 
     * @param {Object} [obj] The object tree to query
     * @param {String|Object} query The query to run
     * @param {Boolean} [breakOnFirst=false] Stop traversing when the first
     *      node satisfies any of the queries
     * @returns {Eligo} The current instance
     */
    traverse: function (obj, query, breakOnFirst) {
        var queries, queryEngine,
            results, qLen, q, f;
        
        this.reset();
        
        obj = obj || this.subject;
        queryEngine = this.queryEngine;
        results = this.results;
        
        query = utils.isArray(query) ? query.toString() : query;

        if (typeof query === 'string') {
            queries = [[queryEngine.parse(query), false]];
        }
        else {
            queries = utils.keys(query).
                map(function (src) {
                    return [queryEngine.parse(src), query[src]];
                });
        }
        
        qLen = queries.length;
        
        this.jaunt.
            on('leave', function (path, jaunt) {
                var i = 0,
                    node;
                
                for (; i < qLen; i++) {
                    node = path.node;
                    q = queries[i];
                    if (q[0].test(path)) {
                        results.push(node);
                        f = q[1];
                        if (f) {
                            path.ffwd();
                            f(path);
                        }
                        if (breakOnFirst) {
                            jaunt.break();
                            break;
                        }
                    }
                }
            }).
            walk(obj);
        
        return this;
    },
    
    reset: function () {
        var opts = this.options,
            esprima = opts.esprima,
            queryOpts;
        
        this.jaunt = this.jaunt ||
            new Jaunt({
                typeKey: esprima ? 'type' : opts.typeKey,
                childKeys: esprima ?
                    require('./esprima/node-child-keys') :
                    opts.childKeys
            });
        
        (this.queryEngine = this.queryEngine ||
            new QueryEngine({
                idKey: opts.idKey,
                typeKey: esprima ? 'type' : opts.typeKey,
                typeAliases: opts.esprima ?
                    require('./esprima/type-aliases') :
                    opts.typeAliases
            })).removeAllListeners();
        
        (this.results = this.results || []).length = 0;
        
        return this;
    }
});
//---------------------------------------------------------------------------
// Exports
//---------------------------------------------------------------------------
Eligo.QueryEngine = QueryEngine;
module.exports = Eligo;
