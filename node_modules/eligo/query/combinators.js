
var utils = require('protean');

function combinatorToString () {
    return this.key;
}
//---------------------------------------------------------------------------
// Exports
//---------------------------------------------------------------------------
Object.defineProperties(exports, {
    define: { value: function define (key, token, fn) {
        this._tokens = null;
        
        this[key] = this[token.source] = this[fn.name] = fn;
        fn.key = key;
        fn.token = token;
        fn.type = 'combinator';
        fn.toString = combinatorToString;
        
        return fn;
    }, enumerable: true },
    
    tokens: { get: function () {
        if (!this._tokens) {
            this._tokens = utils.chain(this).
                keys().
                map(function (key) {
                    var fn;
                    if (key !== 'define' &&
                        key !== 'tokens' &&
                        key !== 'parse' &&
                        (fn = exports[key]) &&
                        typeof fn === 'function' &&
                        fn.token instanceof RegExp
                    ) {
                        return fn.token;
                    }
                }).
                compact().
                sort(function (a, b) {
                    return b.source.length - a.source.length;
                }).
                value();
        }
        return this._tokens;
    }, enumerable: true },
    
    parse: { value: function (scanner) {
        var combinator = null;
        
        this.tokens.
            some(function (token) {
                if (scanner.scan(token)) {
                    combinator = exports[token.source];
                    return true;
                }
            });
        
        return combinator;
    }, enumerable: true }
});
//---------------------------------------------------------------------------
// Combinators
//---------------------------------------------------------------------------
exports.define(' ', (/\s*/), function descendent (pathCursor, selector) {
    var p = pathCursor.parent;
    
    while (p) {
        if (selector.test(p)) {
            return true;
        }
        p = pathCursor.parent;
    }
    
    return false;
});

exports.define('>', (/\s*>\s*/), function child (pathCursor, selector) {
    var node = pathCursor.node,
        p = pathCursor.parent,
        children = pathCursor.getChildren();
    
    return !!(selector.test(p) && ~children.indexOf(node));
});

exports.define('~', (/\s*~\s*/), function sibling (pathCursor, selector) {
    var node = pathCursor.node,
        p = pathCursor.parent,
        children = pathCursor.getChildren(),
        i = children.indexOf(node);
    
    if (i > 0) {
        while (i--) {
            if (selector.test(children[i])) {
                return true;
            }
        }
    }
    
    return false;
});

exports.define('+', (/\s*\+\s*/), function adjacentSibling (pathCursor, selector) {
    var node = pathCursor.node,
        p = pathCursor.parent,
        children = pathCursor.getChildren(),
        nodeIdx = children.indexOf(node);
    
    return ~nodeIdx && selector.test(children[nodeIdx - 1]);
});
