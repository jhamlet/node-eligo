
var utils = require('eligo/utils'),
    Trek = require('ambulo'),
    Query = require('eligo/query');
/**
 * @constructor
 * @param {Object} opts 
 *      @property {String} [opts.typeKey] Object key to determine child nodes
 *      @property {Array|Object} [opts.childKeys] Child keys of nodes
 *      @property {Trek} [opts.trek] Optional object to use for
 *          traversal of the object tree.
 * @param {Object} [obj] Optional object to query on
 */
function Eligo (opts, obj) {
    this.options = opts || {};
    this.subject = obj;
}

Eligo.prototype = {
    /**
     * Return the first node that satisfies the query from obj
     * @param {Object} [obj] The object tree to query
     * @param {String} query The query to run
     * @param {Boolean} [all=false] Get all nodes that match
     * @returns {Object|null}
     */
    select: function (obj, query, all) {
        var opts = this.options,
            results;
        
        if (typeof obj === 'string') {
            query = obj;
            obj = null;
        }
        
        obj = obj || this.subject;
        
        this.reset();
        
        this.traverse(obj, query, !!all);
        
        results = this.results;
        
        return results.length ?
            all ? results : results[0] :
            null;
    },
    /**
     * Return all nodes that satisfy the query from obj
     * @param {Object} [obj] The object tree to query
     * @param {String} query The query to run
     * @returns {Object[]|null}
     */
    selectAll: function (obj, query) {
        return this.select(obj, query, true);
    },
    /**
     * Select all nodes that match any of the supplied queries from obj
     * @param {Object} [obj] The object tree to query
     * @param {String[]} queries The queries to run
     * @returns {Object[]|null}
     */
    selectMany: function (obj, queries) {
        if (utils.isArray(obj)) {
            queries = obj;
            obj = null;
        }
        
        this.traverse(obj, queries, false);
        
        return this.results.length ? this.results : null;
    },
    /**
     * Traverse the supplied obj and test every node against the supplied
     * queries.  If the optional 'breakOnFirst' parameter is truthy, then
     * break when the first node matches any of the given queries.
     * 
     * @param {Object} [obj] The object tree to query
     * @param {String[]} queries The queries to run
     * @param {Boolean} [breakOnFirst=false] Stop traversing when the first
     *      node satisfies any of the queries
     * @returns {Eligo} The current instance
     */
    traverse: function (obj, queries, breakOnFirst) {
        var trek,
            results,
            qLen;
        
        this.reset();
        
        obj = obj || this.subject;
        queries = (utils.isArray(queries) ? queries : [queries]).
            map(function (q) { return new Query(q); });
        results = this.results;
        qLen = queries.length;
        
        this.trek.
            on('leave', function (node, path, trek) {
                var i = 0;
                
                for (; i < qLen; i++) {
                    if (queries[i].test(node, path)) {
                        results.push(node);
                        if (breakOnFirst) {
                            trek.break();
                            break;
                        }
                    }
                }
            }).
            walk(obj);
        
        return this;
    },
    
    reset: function () {
        var opts = this.options,
            trek = this.trek,
            results = this.results,
            queryFactory = this.queryFactory,
            TrekCtor,
            QueryFactoryCtor;
        
        if (!trek) {
            TrekCtor = opts.trek || Trek;
            trek = this.trek =
                new TrekCtor(
                    ['typeKey', 'childKeys'].
                        reduce(function (acc, key) {
                            if (utils.has(opts, key)) {
                                acc[key] = opts[key];
                            }
                            return acc;
                        }, {})
                );
        }
        
        if (!results) {
            results = this.results = [];
        }
        
        if (!queryFactory) {
            this.queryFactory = new Query({
                typeAliases: opts.typeAlias
            });
        }
        
        trek.removeAllListeners();
        results.length = 0;
        
        return this;
    }
};
//---------------------------------------------------------------------------
// Exports
//---------------------------------------------------------------------------
module.exports = utils.extend(Eligo, {
    utils: utils,
    // rule: rule,
    // selector: selector
});